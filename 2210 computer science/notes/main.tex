\documentclass{article}

\usepackage{amsmath, tcolorbox}

\begin{document}
\tableofcontents \newpage
\section {Data Representation}
\subsection{Number systems}

\subsubsection{Computers and binary}
The number system consisting of digits 0 through 9 is called the denary or decimal system
(10 digits). Computers use another number system called binary, consisting of digits
0 through 1. This is done such that computers are able to pass the data through logic 
gates and can be stored in registers.

\subsubsection{The binary, denary and hexadecimal systems}
The number of digits in a number system is the base of that system; denary is base 10;
binary is base 2; hexadecimal is base 16.

\subsubsection*{Conversions}
From positive denary to positive binary:
\begin{enumerate}
	\item Perform short division on given denary number, taking note of the remainders.
	\item Write the remainders from bottom to top, resulting in the binary number.
\end{enumerate}
From positive binary to positive denary:
\begin{enumerate}
	\item Write the binary number with their \textit{place powers}.
	\item Sum the products of each binary digit with the place power, resulting in the
		converted denary number.
	\item Write the remainders from bottom to top, resulting in the binary number.
\end{enumerate}
From positive denary to positive hexadecimal:
\begin{enumerate}
	\item Convert given number to binary
	\item Split resulting binary number to four-bit parts.
	\item Convert the four-bit binaries to denary.
	\item 1 = 1; 2 = 2; ... 10 = A; 11 = B; 12 = C; 13 = D; 14 = E; 15 = F.
	\item Arrange resulting digits side-by-side.
\end{enumerate}
From positive hexadecimal to positive denary:
\begin{enumerate}
	\item Convert each given hex number to denary using the index in step 4 of 
		denary-hex.
	\item Convert each denary number to binary.
	\item Arrange the resulting four-bit binary pieces, producing binary result.
\end{enumerate}
From positive hexadecimal to positive binary:
\begin{enumerate}
	\item Convert to denary.
	\item Convert to binary.
\end{enumerate}
From positive binary to positive hexadecimal:
\begin{enumerate}
	\item Convert to binary.
	\item Convert to denary.
\end{enumerate}

\subsubsection{Uses of the hexadecimal system}
The hexadecimal number system is used to make life easier for humans dealing with 
bare low-level computer code. Hexadecimal requires less digits, and are easier to compare
with the naked eye. Data errors can be easier to find when looking at this shortened form
of binary, hexadecimal.

\subsubsection{Binary addition}
To add two binary numbers, refer to the following:\\
\begin{itemize}
	\item $0 + 0 = 0$.
	\item $1 + 0 = 1$.
	\item $1 + 1 = 10$. (the one is carried on)
	\item $10 + 1 = 11$. (the one is carried on)
\end{itemize}

Sometimes, the addition results in an extra bit, which \textbf{overflows} off. This is
because computers have predifined limits to which it can store its numbers (16, 32 bits)
and when a value outside this limit is returned, it is not stored and an overflow error
occurs.

\subsubsection{Logical binary shifts}
When performing logical shifts, we simply move the bits of a binary number to the right
or left depending on what is required. We ``delete" and hence lose the leftmost (most 
significant) or rightmost (least significant) bit depending on the direction of the shift 
performed.

Shifting right means dividing by two.

Shifting left means multiplying by two.

\subsubsection{Two's complement}
Two's complement is a method used to represent negative binary numbers. We simply
convert given denary number to binary (if need be), invert all the bits and add $(1)_2$ 
to the result.

\subsection{Text, sound and images}
\subsubsection{Text}
Text is converted to binary so that a computer can process it. It does so by converting
each character into an integer, as defined in the \textbf{ASCII} standard (American 
Standard Code For Information Interchange) and subsequently into a binary number.

\textbf{Unicode} is another such standard, which allows a greater range of characters, in
various languages, as a result it also requires more bits per character.

\subsubsection{Sound}
Sounds are composed of waves. When we record values of the sound, we do so at set 
intervals, this process is called \textbf{sampling}. The more samples taken per unit
time, the more accurate the sound recorded will be, i.e., higher the \textbf{sample rate}
the greater the sound quality.

The sound values, which are usually denary numbers, can be converted to binary and stored
into a computer.

The \textbf{sample resolution} is the number of bits allocated per sample value. So, the 
larger the sample resolution, the more the amount of digits that can be stored into a 
file. Thus, the higher the sample resolution, the higher the sound quality.

The file size of a sound file increases, with increased sample rate and sample 
resolution, that means storing high quality sound requires more space that low quality
sound.

\subsubsection{Images}
An image is composed of \textbf{pixels}. The computer stores these pixels by processing
them to binary, by assigning a binary number to a certain colour. 

The \textbf{resolution} of an image is the number of pixels stored in it. Usually in the
format: width $\times$ height.

The \textbf{colour depth} of an image is the number of bits allocated for each pixel
of the image. Higher the colour depth, the more the number of colours that can be
displayed.

Higher quality images result in larger file sizes as resolution and colour depth are 
large.

\subsection{Data storage and compression}
\subsubsection{Measurement of data storage}
\begin{itemize}
	\item Bit: 1 or 0. Smallest possible data measurement.
	\item Nibble: 4 bits.
	\item Byte: 8 bits.
	\item Kibibyte (KiB): 1024 Bytes.
	\item Mebibyte (MiB): 1024 Kibibytes.
	\item Gibibyte (GiB): 1024 Mebibytes.
	\item Tebibyte (TiB): 1024 Gibibytes.
	\item Pebibyte (PiB): 1024 Tebibytes.
	\item Exbibyte: (EiB) 1024 Pebibytes.
\end{itemize}

\subsubsection{File size calculation}
To calculate the file size of an image, find the product of the image's width, height, 
colour depth

For the sound's file size, multiply the sample rate, sample resolution and soundtrack
length.

\subsubsection{Compression}
Files can be compressed to:
\begin{itemize}
	\item Reduce storage space needed.
	\item Less transmission times among devices.
	\item Quicker upload and download times.
	\item Requires less bandwidth for file transmission.
\end{itemize}
Compression is of two types:
\begin{enumerate}
	\item Lossy: Reduces file size by permanently reducing colour depth, resolution, or 
		sample rate.
	\item Lossless: Reduces file size without permanent loss of data, using Run Length
		Encoding (RLE). RLE groups similar data together and hence some file space can
		be saved.
\end{enumerate}

\section{Data transmission}
\subsection{Types and methods of data transmission}
\subsubsection{Packets and transmission}
When data is transmitted from one device to another, it is organised into packets. A 
packet consists of three parts:
\begin{itemize}
	\item Header: Consisting of three parts again: destination address, packet number and
		originators address. 

		The destination address is an Internet Protocol (IP) address
		which is a unique identifier address for every computer connected to the internet.
		
		The packet number assigned to a packet helps the recieving computer reorder and
		organise the data sent, because often data may be sent out of order.

		The originators address too is an IP address. It is that of the device from which
		data has been sent. It helps to trace origin of transmitted data.
	\item Payload: Consists of the actual data being sent.
	\item Trailer (Footer): Consists of data for any error detection system, and the 
		data to signal to the reciever that this is the end of the packet.
\end{itemize}

Data is transmitted across a network (the internet for the majority of cases). Networks
consist of routers. From one device to another, there exist multiple connected routers
amongst whom there exists multiple paths whicch data packets can take. The routes are
decided by the routers themselves. Packets may arrive out of order as a result but the
packer number stored in the header helps the reciever reorder the recieved data. This is
the process of packet switching.

\subsubsection{Methods of dataa transmission}
There are two methods of data transmission regarding the volume of data transferred:
\begin{itemize}
	\item Serial: Data is transmitted along a single wire a bit at a time. Sequencec is
		maintained, very little interference is likely and cheaper for manufacturer and
		consumer because only requires one wire. 

		However, data transmission is very slow 
		and start and stop bits must be sent additionally.
	\item Parallel: Data is transmitted along multiple wires, multiple bits at a time. 
		Data transmission is quicker, because of the sending of multiple bits at one time.
		No need for conversion for transmission across networks as computers use parallel
		transmissions internally. 

		However, the bits may arrive out of order and skewing is a risk. Interference is 
		likely and errors may arise. Expensive due to more wires required.
\end{itemize}
There are three methods of data transmission regarding the direction of data transferred:
\begin{itemize}
	\item Simplex: Data is transferred in one direction only.
	\item Half-duplex: Data is transferred in both directions, not at the same time.
	\item (Full-)Duplex: Data is transferred in both directions at the same time.
\end{itemize}

\subsubsection{The universal serial bus (USB) interface}
The USB interfaec inclcudes the port, cable, connection and device. Data transmission, 
here is a special type of serial which allows high speed transmissions.

The USB interface is simple and connections can only be made in one way, less errors in
onnecting devices are likely. The speed of data transfer is quite high. It is the 
industry standard so almost all devices are equipped with a USB port. When USB devices are
connected, required drivers for the devices are automatically detected and downloaded.
It does not need its own power source and can be used to charge devices.

The length of a USB cable is limited to a maximum of five metres. Transmission is quick
yet not as quick as ethernet.

\subsection{Methods of error detection}
\subsubsection{Necessity of error checking}
Errors may occur as a result of interference during transmission, consisting of loss, gain
and change of data being transmitted.

\subsubsection{Processes to detect errors}
These errors can be resolved in the following ways:
\begin{itemize}
	\item Parity check: Given data is said to have even or odd parity. Bytes of data are
		sent with a parity bit, which is determined by the data itself. If the number of
		ones in the binary data is even and the parity is even, the parity bit will be 
		one, otherwise zero. Same stands for odd parity.
	\item Checksum: A calculated value is transmitted with transmitted using a certain
		method. The reciever then uses the same method to calculate the value itself.
		If the transmitted and calculated values match, the data is error-free, otherwise
		it is corrupt.
	\item Echo check: Recieved data is sent back to the sender, who compares it with 
		original data. If datas match, no error. Otherwise data is sent again.
\end{itemize}

\subsubsection{Check digits}
Check digits are identical to checksums but the the result of the generating algorithm
is in a single digit. ISBN (International Standard Book Numbers) use check digits and
so do barcodes.

\subsubsection{Automated Repeat Queries (ARQ)}
ARQs work in the following sequence:
\begin{enumerate}
	\item Data is sent to reciever.
	\item Reciever checks errors.
	\item If data free, send positive acknowledgement to sender.
	\item Otherwise send negative acknowledgement and sender re-sends data.
	\item If no acknowledgement is sent beyond the timeout limit, sender sends data again.
	\item Without acknowledgement, data is sent for a set number of times.
\end{enumerate}

\subsection{Encryption}
\subsubsection{The need for data transmission}
Data needs to be encrypted so as not to lose sensitive data to potential hackers.

The original data is called the plaintext, having used an encryption algorithm, usually
with an encryption key, a ciphertext is formed. This ciphertext is then sent across the
network and some method of data decryption is used by reciever.

\subsubsection{Methods of data encryption}
Data can be encrypted in two ways:
\begin{enumerate}
	\item Symmetric: Data is encrypted and decrypted using the same encryption key which is 
		send along with the data itself. Vulnerable method as encryption key can also be 
		compromised.
	\item Asymmetric: Data is encrypted with the senders public key, decrypted with 
		public key. This is the safer method as compromise is unlikely with only public
		key.
\end{enumerate}

\section{Hardware}
\subsection{Computer architecture}
\subsubsection{The central processing unit (CPU)}
It is responsible for the process of data inputted into the computer to turn it into an
output. A microprocessor is present in embedded systems and is an integrated circuit 
which is able to perform many of the functions of a CPU.

\subsubsection{The Von Neumann architecture}
The Von Neumann architecture consists of three stages in a cycle: fetch, decode and 
execute.

\begin{itemize}
	\item Fetch: 
		\begin{enumerate}
			\item Inputted data, instructions and data from hard drive are initially 
				stored and put into the RAM (Random Access Memory).
			\item A register called the PC (Program Counter) stores the address of the next
				instruction to be processed. The address is the next location of RAM.
			\item When an instruction is to be processed, the address from the PC is 
				brought into the MAR (Memory Address Register). The address bus is used for
				the movement of registers.
			\item Using the address stored in the MAR, the address bus retrieves the data
				at the address in the RAM, bringing it back into the MDR (Memory Data
				Register) using the data bus.
			\item Once the MDR recieves the data, which is the next instruction to be
				processed, this data is sent to the CIR (Current Instruction Register). The
				transfer is done by the data bus.
			\item This is the end of the fetch stage, the CIR is part of the CU (Control
				Unit) which is responsible for the second stage: decode.
		\end{enumerate}
	
	\item Decode:
		\begin{enumerate}
			\item Using an instruction set, the CU decodes the instruction stored in the
				CIR.
			\item This is the end of the decode stage, now the execute stage can begin.
		\end{enumerate}

	\item Execute:
		\begin{enumerate}
			\item Here actions required for carrying-out of instructions are done.
			\item Calculations are done by the ALU (Arithmetic Logic Unit). The ALU
				has a register called the ACC (ACCumulator) where any temporary values
				needing to be stored are stored.
		\end{enumerate}
\end{itemize}
The stages in the fetch-code-decode cycle are coordinated by signals transmitted through
the control bus.

\subsubsection{CPU Performance}
CPU Performance is controlled by three main factors: number of cores, clock speed and 
cache.

\begin{itemize}
	\item Cores: The more the number of cores the better the performance as more fetch-
		decode-execute cycles can run simultaneously.
	\item Clock speed: A CPU contains an internal clock which controls speed of 
		processing of instructions. Using overclocking, CPU can process more instructions
		quicker but it can cause overheating.
	\item Cache size: Cache is a type of storage inside and hence near the CPU. 
		The more instructions stored in cache the better as it takes less time than 
		fetching instructions all the way from RAM.
\end{itemize}

\subsubsection{Embedded systems}
Embedded systems are essentially small computers that are built to do a very specific 
task. Examples include the systems embedded into domestic appliances (microwaves, 
fridges, etcetera), vending machines, security systems or lighting systems. They use
microcontrollers in place of a CPU and usually lack some parts of the Von Neumann 
architecture.

\subsection{Input and output devices}
An input device is that which allows any entering of data into a computer system, 
including text, image and sound. 

Required input devices:
\begin{itemize}
	\item Barcode scanner: Used to scan data encoded into a barcode (a linear image 
		consisting if dark and light lines).
	\item QR (Quick Response) code scanner: Used to scan data incoded into a QR code (an
		image consisting of dark and light squares arranged in a matrix pattern).
	\item Digital camera: Used to take digital images of surroundings.
	\item Keyboard: Used to type in text into a computer system.
	\item Microphone: Used to input sound data into a computer system.
	\item Optical mouse: A pointing device which uses a CMOS (Complementary Metal Oxide
		Semiconductor) to detect movement and maps that movement into the pointer on
		the screen.
	\item Touchscreen: Can be of three types: capacitive, resistive and infrared:
		\begin{itemize}
			\item Capacitive: Voltages are produced at all four corners of the screen,
				any contact by finger or stylus results in change in electric field 
				produced, position of contact can then be calculated.
			\item Resistive: Consists of two layers, when pressure is applied, the layers
				come into contact, completing a circuit and position of contact is
				calculated.
			\item Infrared: Infrared light beams are shot across thes screen in an X-Y
				pattern. When a finger or stylus contacts the screen, the light rays are
				blocked and the position of contact can easily be calculated.
		\end{itemize}

	\item 2D and 3D scanners: 2D scanners are used to scan what is printed onto a piece
		of paper, a document. This is done to digitise the document.

		3D Scanners scan and produce a 3D image of a given object. This can be used in
		CAD (Computer Aided Design) circumstances.
\end{itemize}
\end{document}
