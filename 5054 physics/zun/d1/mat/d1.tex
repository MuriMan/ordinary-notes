\documentclass{article}
\usepackage{hyperref, fancyvrb}

\renewcommand*{\thefootnote}{[\arabic{footnote}]}
\newcommand{\gcc}{\Verb|gcc|}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\urlstyle{same}

\begin{document}
\section*{Programming, D1}

\subsection*{Introduction}
Programming a computer is simply telling it what to do. Understand that a computer can only do
one thing, move data around and change it. From this simple behaviour arises mechanics complex
enough to simulate whole universes.

When you're browsing, watching videos, playing games or whatever the fuck on your computer, the
computer doesn't know that you're doing this. The computer knows that you're telling it to move
this certain block of data to a certain place and change it in a certain way. Your output devices,
speakers, monitors etc., interpret these data and produce a corresponding output.

\subsection*{Now for the fun stuff}
Go to \href{https://code.cs50.io}{cs50.io}. You'll be brought to your coding environment. Set up
a GitHub account, after which it will take some time to set up. Yours truly will show you how to 
navigate this environment.

Some commands to note\footnote{Everything in between angled brackets, \Verb|<>|, is a placeholder
and something else may be in that place.}:
\begin{itemize}
	\item \verb|touch <filename>| creates a file with name \verb|<filename>|.
	\item \verb|rm <filename>| deletes a file with name \verb|<filename>|.
	\item \verb|mkdir <name>| creates a folder (directory) with name \verb|<name>|.
	\item \verb|rm -r <name>| removes a directory with name \verb|<name>|\footnote{The \Verb|-r| in
	this command stands for ``recursively", which means to do it repeatedly until it's done.}.
	\item \verb|cd <name>| changes current directory into directory with name \verb|<name>|.
	\item \verb|code <filename>| opens the file named \verb|<filename>| into the editor.
\end{itemize}

\subsubsection*{A programming language}
Remember my little computer science note about what binary is and why it is? Well the problem with
that is computers understand only binary, nothing other than it. Us humans don't understand binary,
so there must be an intermediary\footnote{Fun fact: People actually used to write binary on things
called ``punchcards". Back then, the field was dominated by women.}. In comes the programming 
language, where we write instructions in a language that is very close to English.

Yet, the code we write still is not binary. To convert these arbitrary, abstract instructions to
something computers can understand, we must \textit{translate} it to an \textit{executable binary
file} using special software called a \textit{compiler}. Note that code that computers can 
understand is called machine code.

We will learn the C programming language, a fan favourite since the 1970s and a very good starting
point. The compiler for C is called \gcc{}. We feed to \gcc{} the code we have written, and the name
of the file into which we would like it to barf out the binary code the machine can read, and it
obeys.

The primary command involving \gcc{} which we will use is:

\begin{center}
\verb|gcc <codefile> -o <outfile>| 
\end{center}
The above tells \gcc{} to compile \verb|<codefile>| and output
the resulting machine code in \verb|<outfile>|.

\subsubsection*{Some boilerplate}
Before we start, we must first conform to some norms. Firstly, we must ``include" the ``standard
i/o library". In other words, we must bring in input/output functionality into our program, doing
which by hand is a momentous task. Fortunately, this has been done for us by some very smart people
five decades ago and all this functionality was put into a file called \verb|stdio.h| (read: 
standard i-o dot h). To do so we add the following line:

\begin{center}
	\begin{BVerbatim}
	#include <stdio.h>
	\end{BVerbatim}
\end{center}
to the very top of our code file.

Next, we must tell \gcc{} from where to start reading and translating the instructions we have
written:
\begin{center}
	\begin{BVerbatim}
	int main(void) 
	{
	  // our code
	}
	\end{BVerbatim}
\end{center}
\gcc{} looks for this exact line: \verb|int main(void)|, from after which it will start translating
our written code.

This brings our boilerplate code file to being:
\begin{center}
	\begin{BVerbatim}
	#include <stdio.h>

	int main(void)
	{
	  // code
	}
	\end{BVerbatim}
\end{center}
Note that, \gcc{} ignores anything written after a pair of forward slashes, \verb|//|. Such a line
is called a comment. In the above, \verb|// code| is an example.

\subsection*{For real this time}
\subsubsection*{Creating data}

To keep track of data we created and are using, we use the concept of \textit{variables}. Every
variable has a type of data it can store, a name, called its identifier, and the data being stored
itself. To tell the computer that we wouldl like some data allocated for our program, we use
the following line:

\begin{center}
	\begin{BVerbatim}
	<datatype> <identifier>;
	\end{BVerbatim}
\end{center}
where \verb|<datatype>| is the type of data being declared and \verb|<identifier>| is the name of
the variable itself. Note the use of a semicolon to denote end of line.

\subsubsection*{Output}
When outputting in C, you must mention the type of data being outputted alongside the data being
outputted itself. Every data type has a \textit{format specifier} with which you can specify the
data type being outputted. A similar thing happens for input. The function \verb|printf()| is used
to output a formatted variable. What functions are, we will get into later, but know that they
take in some things and spit out some others depending on what you fed it. The things being fed
are called \textit{arguments}.

The \verb|printf()| function takes in two arguments, \verb|printf(<format>, <var>)|.


\end{document}
